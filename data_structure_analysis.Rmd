---
title: "Descriptive reporting template"
author: "Dana Weisenfeld, Suvam Paul"
date: 'Last updated: `r format(Sys.Date(), "%B %d, %Y") ` '
output:
  html_notebook:
    highlight: tango
    theme: cosmo
    toc: yes
    toc_depth: 4
  html_document:
    toc: yes
    toc_depth: '4'
---

# Setup
## Load packages
## Read in database credentials and open connection

```{r setup, message = FALSE, echo = FALSE}
knitr::read_chunk("setup_notebook_dana.R")
```

```{r setup_notebook}
```

```{r echo = FALSE}
print_loaded_pkgs()
```

```{r addl_setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(VIM)
library(xtable)
```

```{r credentials}

tables_list <- dbListTables(edu_deid_con)

clean_tables <-  get_tbl_names_by_stage(edu_deid_con, "deidentified", "clean")

# gpa
dat <- dbUtilities::put_tbl_to_memory(edu_deid_con, clean_tables[4])

#list tof tiblles
tbl <- dbUtilities::get_tbls_by_pattern(edu_deid_con, "\\Wclean\\Wgpa|\\Wclean\\Wexperiences")


```


```{r miss_plot}

# percent missing in each numeric var
pct_miss <- dat %>%
  dplyr::group_by(appl_year) %>%
  summarize_all(funs(pct_missing = mean(is.na(.)))) %>%
  column_to_rownames("appl_year") %>%
  t() %>%
  multiply_by(100) %>%
  round(., 2)


# visually display missings
aggr(dat, bars=FALSE, numbers=FALSE, sortVars=TRUE)


#what does aggr return?
miss_obj <- aggr(dat, bars = FALSE, sortVars = TRUE, numbers = TRUE, plot = TRUE)

print(miss_obj)
summary(miss_obj)



######## refactor of code to explore a single tibble and a list of tibbles#######

# a single tibble
explore_missingness_single <- function(dat, plot = TRUE) {
  
  miss_obj <- aggr(dat, bars = FALSE, sortVars = TRUE, numbers = TRUE, plot = plot)
  summary(miss_obj)
  
}




#a list of tibbles
explore_missingness <- function(df_list, plot = TRUE) {
  
  df_list %>% 
    map(., function(df)
      explore_missingness_single(df, plot = plot))
}



summary(explore_missingness_single(dat, plot = TRUE))
explore_missingness(tbl, plot = TRUE)



#group a list of tibble by application year each year and return...
#how to return the a named list that's the app_year

tbl %>%
  map(.,function(df) {
    df %>% 
      group_by(appl_year) %>% 
      nest() %>%
      mutate(var = map(data, explore_missingness_single))
  }) %>%
  map(., "var", extract)





# complete cases

#a single tibble

get_complete_cases_single <- function(dat) {
  
  sum(complete.cases(dat)/nrow(dat))
}


# a list of tibbles


get_complete_cases <- function(df_list) {
  
  df_list %>% 
    map(., function(df)
      get_complete_cases_single(df))
  
}



get_complete_cases_single(dat)

tbl %>% get_complete_cases()


#group by application year?

###################################################################################
```


`r complete.obs`% of observations in data are complete. 


```{r}

# converting application year to character
dat$appl_year <- as.character(dat$appl_year)

# converting study_id to factor so it is ignored
dat$study_id <- as.factor(dat$study_id)

# summarize variables

classes <- dat %>% map(class) %>% sapply(function(x) x[1])
names(classes) <- NULL

nums <- which(classes=="numeric")
binaries <- nums[apply(dat[nums],2,function(x) { all(na.omit(x) %in% 0:1) })]
continuous <- setdiff(nums, binaries)
  
cats <- which(classes=="character")
dates <- which(classes=="POSIXct")

```

###Summary Statistics

There are `r length(continuous)` continuous numeric variables in the dataset.

```{r summarize_continuous_vars}

if (length(continuous)>0) {
  
dat <- as.data.frame(dat)

sumstats <- matrix(NA, nrow=length(continuous)*4, 9, dimnames=list(c(), 
                  c("Year", "N", "Min", "Q1", "Median", "Mean", "Q3", "Max", "SD")))
j = 1
for (i in 1:length(continuous)) {
  for (y in unique(dat$appl_year)) {
    sumstats[j,1] <- y
    sumstats[j,2] <- sum(!is.na(dat[dat$appl_year==y,continuous[i]]))
    sumstats[j,3] <- min(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,4] <- quantile(dat[dat$appl_year==y,continuous[i]], .25, na.rm=TRUE)
    sumstats[j,5] <- median(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,6] <- round(mean(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE),2)
    sumstats[j,7] <- quantile(dat[dat$appl_year==y,continuous[i]], .75, na.rm=TRUE)
    sumstats[j,8] <- max(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,9] <- round(sd(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE),2)
    j = j + 1
  }
}

# row names
new_seq <- seq(1, to = nrow(sumstats), by = 4)

row_names <- rep("", nrow(sumstats))

for(i in 1:length(continuous)) {
  row_names[new_seq[i]] <- names(dat)[continuous[i]]
}

row.names(sumstats) <- row_names

kable(sumstats)
}




##########################refeactor summary for numerical variables##############

twentyfive_quantile <- function(a_vec,...) {
  unname(quantile(a_vec, .25, ...))
}


seventyfive_quantile <- function(a_vec,...) {
  unname(quantile(a_vec, .75, ...))
}


get_basic_summaries_single <- function(dat, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  
  dat %>% 
    group_by(!!quo_group_by) %>% 
    summarise_if(., is.numeric, funs(min, max, mean, median, twentyfive_quantile, seventyfive_quantile), na.rm = TRUE)
}


get_basic_summaries <- function(df_list, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  

  df_list %>% 
    map(., function(df) {
      df %>% 
        group_by(!!quo_group_by) %>% 
          summarise_if(., is.numeric, funs(min,max, mean, median, twentyfive_quantile, seventyfive_quantile), na.rm = TRUE)
    }
  )
}


get_basic_summaries_single(dat, appl_year)

get_basic_summaries(df_list = tbl, varname = appl_year)



################################################################################


```

There are `r binaries` binary variables in the dataset. 
 
```{r binaries}

if (length(binaries) > 0) {
  
binary_mat <- matrix(NA, nrow=length(binaries), 2, dimnames=list(c(), 
                  c("N", "Proportion"))) 
  
binary_mat[i,1] <- sum(!is.na(dat[,binaries[i]]))
binary_mat[i,2] <- mean(dat[,binaries[i]], na.rm=TRUE)

row.names(binary_mat) <- names(dat)[binaries]

kable(binary_mat)

}


```

###Correlation Matrix

```{r corr_matrix}

cor_mat <- round(cor(dat[nums], use = 'pairwise.complete.obs'),2)

kable(cor_mat)


#for a single tibble
get_cor_mat_single <- function(dat, use = 'pairwise.complete.obs') {
  
  dat %>% 
    select_if(is.numeric) %>% 
    cor(., use = use)
}


#for a list of tibbles
get_cor_mat <- function(df_list, use = 'pairwise.complete.obs') {
  
  df_list %>% 
    map(., function(df)
      get_cor_mat_single(df, use = use))
    
}


get_cor_mat_single(dat)

get_cor_mat(tbl)


#group a list of tibbles by application year for each tibble and then return?

tbl %>%
  map(.,function(df) {
    df %>% 
      group_by(appl_year) %>% 
      nest() %>%
      mutate(var = map(data, get_cor_mat_single))
  }) %>%
  map(., "var", extract) 
  
```

```{r histograms}

# l <- length(nums)
# 
# if (l <= 5) { par(mfrow=c(1,l)) }
# if (l >5 & l <= 10) {
#   if (l %% 2 == 0) { par(mfrow=c(2, l/2)) }
#   else { par(mfrow=c(2,5)) }
# }
# if (l > 10) {
#   par(mfrow=c(l %/% 5 + 1, 5))
# }

for (i in nums) {
  var <- names(dat)[i]  
  hist(dat[,i], main = var, xlab="", ylab="")
}

```


```{r categorical_tables, results='asis'}

# Want N's and proportions in each category
for (i in 1:length(cats)) {
  rawN <- sort(as.numeric(table(dat[,cats[i]])), decreasing=TRUE)
  prop <- sort(round(as.numeric(prop.table(table(dat[,cats[i]]))),2), decreasing=TRUE)

  col_names <- names(table(dat[,cats[i]]))
  
  if (length(rawN) > 10) {
    rawN <- rawN[1:10]
    prop <- prop[1:10]
    col_names <- names(table(dat[,cats[i]]))[1:10]
    }
  
  cells <- paste0(rawN, " (", prop, ")")
  names(cells) <- col_names
  #cells <- as.matrix(cells, ncol=4, dimnames = list(c(), col_names))

  print(kable(t(cells)), caption = names(dat[cats[i]]))
}

```


```{r dates}

```