---
title: "Descriptive reporting template"
author: "Dana Weisenfeld, Suvam Paul"
date: 'Last updated: `r format(Sys.Date(), "%B %d, %Y") ` '
output:
  html_notebook:
    highlight: tango
    theme: cosmo
    toc: yes
    toc_depth: 4
  html_document:
    toc: yes
    toc_depth: '4'
---

# Setup
## Load packages
## Read in database credentials and open connection

```{r setup, message = FALSE, echo = FALSE}
knitr::read_chunk("setup_notebook_dana.R")
```

```{r setup_notebook}
```

```{r echo = FALSE}
print_loaded_pkgs()
```

```{r addl_setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(VIM)
library(xtable)
```

```{r credentials}

tables_list <- dbListTables(edu_deid_con)

clean_tables <-  get_tbl_names_by_stage(edu_deid_con, "deidentified", "clean")

# gpa
dat <- dbUtilities::put_tbl_to_memory(edu_deid_con, clean_tables[4])

#list of tibbles
tbl <- dbUtilities::get_tbls_by_pattern(edu_deid_con, "\\Wclean\\Wgpa|\\Wclean\\Wexperiences")

#appl 

appl <- dbUtilities::put_tbl_to_memory(edu_deid_con, clean_tables[1])
```


```{r miss_plot}

# percent missing in each numeric var
pct_miss <- dat %>%
  dplyr::group_by(appl_year) %>%
  summarize_all(funs(pct_missing = mean(is.na(.)))) %>%
  column_to_rownames("appl_year") %>%
  t() %>%
  multiply_by(100) %>%
  round(., 2)


# visually display missings
aggr(dat, bars=FALSE, numbers=FALSE, sortVars=TRUE)


#what does aggr return?
miss_obj <- aggr(dat, bars = FALSE, sortVars = TRUE, numbers = TRUE, plot = TRUE)

aggr(dat, sortVars=TRUE, numbers=FALSE, prop=c(TRUE, TRUE), plot=TRUE)

print(miss_obj)
summary(miss_obj)



######## refactor of code to explore a single tibble and a list of tibbles#######

# a single tibble
explore_missingness_single <- function(dat, plot = TRUE) {
  
  miss_obj <- aggr(dat, bars = FALSE, sortVars = TRUE, numbers = TRUE, plot = plot)
  #summary(miss_obj)
  
}




#a list of tibbles
explore_missingness <- function(df_list, plot = TRUE) {
  
  df_list %>% 
    map(., function(df)
      explore_missingness_single(df, plot = plot))
}



summary(explore_missingness_single(dat, plot = TRUE))
explore_missingness(tbl, plot = TRUE)



#group a list of tibbles by application year each year and return...
#how to return the a named list that's the app_year

tbl %>%
  map(.,function(df) {
    df %>% 
      group_by(appl_year) %>% 
      nest() %>%
      mutate(var = map(data, explore_missingness_single))
  }) %>%
  map(., "var", extract)



# complete cases

#a single tibble

get_complete_cases_single <- function(dat) {
  
  sum(complete.cases(dat)/nrow(dat))
}


# a list of tibbles


get_complete_cases <- function(df_list) {
  
  df_list %>% 
    map(., function(df)
      get_complete_cases_single(df))
  
}



get_complete_cases_single(dat)

tbl %>% get_complete_cases()


#group by application year?

###################################################################################
```


__% of observations in data are complete. 


```{r}

# converting application year to character so it doesn't get summarized with numerics
dat$appl_year <- as.character(dat$appl_year)

# converting study_id to factor so it is ignored during summaries
dat$study_id <- as.factor(dat$study_id)


classes <- dat %>% map(class) %>% unlist %>% unname

nums <- which(classes=="numeric")
binaries <- nums[apply(dat[nums], 2, function(x) { all(na.omit(x) %in% 0:1) })]
continuous <- setdiff(nums, binaries)
  
cats <- which(classes=="character")
dates <- which(classes=="POSIXct")

# identifies Y/N/NA and Y/NA variables
# what to return? var names? index number?
identify_yesno <- function(dat) {
  dat %>% 
    sapply(., function(x) { all(na.omit(x) %in% c("Y", "N")) })
}



```

###Summary Statistics

There are `r length(continuous)` continuous numeric variables in the dataset.

```{r summarize_continuous_vars, eval=FALSE}

if (length(continuous)>0) {
  
dat <- as.data.frame(dat)

sumstats <- matrix(NA, nrow=length(continuous)*4, 9, dimnames=list(c(), 
                  c("Year", "N", "Min", "Q1", "Median", "Mean", "Q3", "Max", "SD")))
j = 1
for (i in 1:length(continuous)) {
  for (y in unique(dat$appl_year)) {
    sumstats[j,1] <- y
    sumstats[j,2] <- sum(!is.na(dat[dat$appl_year==y,continuous[i]]))
    sumstats[j,3] <- min(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,4] <- quantile(dat[dat$appl_year==y,continuous[i]], .25, na.rm=TRUE)
    sumstats[j,5] <- median(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,6] <- round(mean(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE),2)
    sumstats[j,7] <- quantile(dat[dat$appl_year==y,continuous[i]], .75, na.rm=TRUE)
    sumstats[j,8] <- max(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE)
    sumstats[j,9] <- round(sd(dat[dat$appl_year==y,continuous[i]], na.rm=TRUE),2)
    j = j + 1
  }
}

# row names
new_seq <- seq(1, to = nrow(sumstats), by = 4)

row_names <- rep("", nrow(sumstats))

for(i in 1:length(continuous)) {
  row_names[new_seq[i]] <- names(dat)[continuous[i]]
}

row.names(sumstats) <- row_names

kable(sumstats)
}

```


```{r summ_stats_cont_vars}

##########################refeactor summary for numerical variables##############

twentyfive_quantile <- function(a_vec,...) {
  unname(quantile(a_vec, .25, ...))
}


seventyfive_quantile <- function(a_vec,...) {
  unname(quantile(a_vec, .75, ...))
}


get_basic_summaries_single <- function(dat, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  
  dat %>% 
    group_by(!!quo_group_by) %>% 
    summarise_if(., is.numeric, funs(min, max, mean, median, twentyfive_quantile, seventyfive_quantile), na.rm = TRUE)
}


# should this function produce one large tibble or a list of tibbles?
# one tibble per variable would be easier to process
get_basic_summaries <- function(df_list, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  

  df_list %>% 
    map(., function(df) {
      df %>% 
        group_by(!!quo_group_by) %>% 
          summarise_if(., is.numeric, funs(min, twentyfive_quantile, median, mean, seventyfive_quantile, max), na.rm = TRUE) 
        
    }
  )
}


get_basic_summaries_single(dat, appl_year)

get_basic_summaries(df_list = tbl, varname = appl_year)



################################################################################


```

There are `r binaries` binary variables in the dataset. 
 
```{r binaries}

if (length(binaries) > 0) {
  
binary_mat <- matrix(NA, nrow=length(binaries), 2, dimnames=list(c(), 
                  c("N", "Proportion"))) 
  
binary_mat[i,1] <- sum(!is.na(dat[,binaries[i]]))
binary_mat[i,2] <- mean(dat[,binaries[i]], na.rm=TRUE)

row.names(binary_mat) <- names(dat)[binaries]

kable(binary_mat)

}

```


```{r}
#functions for binary data

#get_binary returns a character vector with the names of the columns that are binary for a data frame
get_binary <- function(df) {
  df %>% 
    summarise_all(funs(n_distinct(., na.rm = TRUE))) %>% 
    t() %>% as.data.frame() %>% 
    rownames_to_column("col_name") %>% 
    filter(V1 <= 2) %>%   
    use_series(col_name)
}

appl %>% get_binary()
names(appl)


table(appl$ses, useNA = "always")
table(appl$dual_degree_applicant, useNA = "always")
table(appl$appl_type_desc, useNA = "always")


#get_binary cols returns only the binary cols plus the appl_year and study_id cols for any data frame
get_binary_cols <- function(df) {
  df %>%
    get_binary() %>%
    {select(df, study_id, appl_year, one_of(.))}
}


```





###Correlation Matrix

```{r corr_matrix}

cor_mat <- round(cor(dat[nums], use = 'pairwise.complete.obs'),2)

kable(cor_mat)


#for a single tibble
get_cor_mat_single <- function(dat, use = 'pairwise.complete.obs', round_digits = 2) {
  
  dat %>% 
    select_if(is.numeric) %>% 
    cor(., use = use) %>%
    round(round_digits)
}


#for a list of tibbles
get_cor_mat <- function(df_list, use = 'pairwise.complete.obs', round_digits = 2) {
  
  df_list %>% 
    map(., function(df)
      get_cor_mat_single(df, use = use, round=round_digits))
    
}


get_cor_mat_single(dat)

get_cor_mat(tbl, round_digits = 3)


#group a list of tibbles by application year for each tibble and then return?
tbl %>%
  map(.,function(df) {
    df %>% 
      group_by(appl_year) %>% 
      nest() %>%
      mutate(var = map(data, get_cor_mat_single))
  }) %>%
  map(., "var", extract) 


```


```{r histograms}

par_rows <- length(continous) %% 4 + 1
par(mfrow=c(par_rows, 4))

# hists <- apply(dat_cont, 2, hist, plot=FALSE)
# lapply(names(hists), function(x) plot(hists[[x]], main=x, xlab="")) # this produces unnecessary output 


for (i in 1:par_rows) {
  hist(dat_cont[,i], main=names(dat_cont)[i], xlab="")
}

```


```{r categorical_tables, results='asis'}

# number of distinct categories for categorical variables by application year
get_ndistinct_single <- function(dat, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  
  dat %>% 
    group_by(!!quo_group_by) %>% 
    summarise_if(., is.character, funs(n_distinct))
}

get_ndistinct_single(dat, appl_year)

######################

## HELPER FUNCTIONS

# creates tables for every categorical variable 
get_cat_tables <- function(dat, varname) {

  quo_group_by <- enquo(varname)
  #print(quo_group_by)
  
  group_var <- dat %>% select(!!quo_group_by) %>% pull()

  table_list <- dat %>% 
    select_if(is.character) %>%
    apply(2, table, group_var, useNA = "always") %>% 
    lapply(t)
  
  return(table_list)
}


# keep 10 largest categories for each variable
keep10_categories <- function(table_list) {
  
  #table_list <- get_cat_tables(dat, varname)
  names <- names(table_list) 
  
  table_list <- lapply(names, function(x) {
    many_cats <- ncol(table_list[[x]]) > 10
    if (many_cats) {
      new_table <- sort(table(dat[[x]]), decreasing=TRUE)[1:10]
      table_list[[x]] <- table_list[[x]][,names(new_table)]
    } else {
      table_list[[x]] <- table_list[[x]]
    }
  })
 
  names(table_list) <- names
  return(table_list)   
}

# takes proportions instead of raw N's     
get_table_props <- function(table_list, digits = 3) {
    table_list <- lapply(table_list, function(x) {
        round(prop.table(x, margin = 1), digits)
    })
    return(table_list)
}


##################
 

format_cat_tables <- function(dat, varname, prop=T, digits = 3)   {
  big_tables <- get_cat_tables(dat, appl_year)
  table_list <- keep10_categories(big_tables)
  if (prop) {
    return(get_table_props(table_list, digits))
  } else {
    return(table_list)
  }
}

cat_tabs <- format_cat_tables(dat, appl_year, prop=T, digits=3)



# format tables for nice display 
categorical_kables <- lapply(names(cat_tabs), function(x) kable(cat_tabs[[x]], caption = x, type='html'))
# categorical_kables



```


```{r props_across_years, eval=FALSE}

# Provides N and proportin in each category across years
for (i in 1:length(cats)) {
  rawN <- sort(as.numeric(table(dat[,cats[i]])), decreasing=TRUE)
  prop <- sort(round(as.numeric(prop.table(table(dat[,cats[i]]))),2), decreasing=TRUE)

  col_names <- names(table(dat[,cats[i]]))
  
  if (length(rawN) > 10) {
    rawN <- rawN[1:10]
    prop <- prop[1:10]
    col_names <- names(table(dat[,cats[i]]))[1:10]
    }
  
  cells <- paste0(rawN, " (", prop, ")")
  names(cells) <- col_names
  #cells <- as.matrix(cells, ncol=4, dimnames = list(c(), col_names))

  print(kable(t(cells)), caption = names(dat[cats[i]]))
}

```


```{r dates}

get_basic_date_summaries_single <- function(dat, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  
  dat %>% 
    group_by(!!quo_group_by) %>% 
    summarise_if(., is.POSIXct, funs(min, twentyfive_quantile, median, seventyfive_quantile, max), na.rm = TRUE)
}


get_basic_date_summaries <- function(df_list, varname) {
  
  quo_group_by <- enquo(varname)
  print(quo_group_by)
  

  df_list %>% 
    map(., function(df) {
      df %>% 
        group_by(!!quo_group_by) %>% 
          summarise_if(., is.POSIXct, funs(min, twentyfive_quantile, median, seventyfive_quantile, max), na.rm = TRUE)
    }
  )
}


get_basic_date_summaries_single(appl, appl_year)

get_basic_dat_summaries(df_list = tbl, varname = appl_year)

```