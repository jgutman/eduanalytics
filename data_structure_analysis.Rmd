---
title: "Descriptive reporting template"
author: "Dana Weisenfeld, Suvam Paul"
date: 'Last updated: `r format(Sys.Date(), "%B %d, %Y") ` '
output:
  html_notebook:
    highlight: tango
    theme: cosmo
    toc: yes
    toc_depth: 4
  html_document:
    toc: yes
    toc_depth: '4'
---

# Setup
## Load packages
## Read in database credentials and open connection

```{r setup, message = FALSE, echo = FALSE}
knitr::read_chunk("setup_notebook_dana.R")
```

```{r setup_notebook}
```

```{r echo = FALSE}
print_loaded_pkgs()
```

```{r addl_setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, fig.align = 'center')
library(VIM)
library(xtable)
source("descriptive_functions.R")
```


```{r credentials}

tables_list <- dbListTables(edu_deid_con)

clean_tables <-  get_tbl_names_by_stage(edu_deid_con, "deidentified", "clean")

# gpa
dat <- dbUtilities::put_tbl_to_memory(edu_deid_con, clean_tables[4])

#list of tibbles
tbl <- dbUtilities::get_tbls_by_pattern(edu_deid_con, "\\Wclean\\Wgpa|\\Wclean\\Wexperiences")

#appl 

appl <- dbUtilities::put_tbl_to_memory(edu_deid_con, clean_tables[1])

```


```{r miss_table, warning=FALSE}

kable(pct_miss_table(dat, appl_year), type='html', caption="Percent missing in each variable by year")

```



```{r missing_plots}

#what does aggr return?
miss_obj <- aggr(dat, bars = FALSE, sortVars = TRUE, numbers = TRUE, plot = TRUE, cex.axis=.8)

aggr(dat, sortVars=TRUE, numbers=FALSE, prop=c(TRUE, TRUE), plot=TRUE, cex.axis=.8)

print(miss_obj)
summary(miss_obj)


######## refactor of code to explore a single tibble and a list of tibbles#######


summary(explore_missingness_single(dat, plot = TRUE))
explore_missingness(tbl, plot = TRUE)



#group a list of tibbles by application year each year and return...

# produces same output as above, but year names are preserved in list headers so output is more readable
tbl %>%
  map(., function(df) {
    df %>% 
      split(use_series(., appl_year)) %>% 
      lapply(select, -appl_year) %>%
      lapply(explore_missingness_single)
    } 
  ) 


# same output as above, but requires plyr
tbl %>%
  map(., function(df) {
    df %>% 
      plyr::dlply(.(appl_year), explore_missingness_single)
  }
)
    
```


```{r complete_cases}
# percent of complete observations

get_complete_cases_single(dat)

tbl %>% get_complete_cases()


# percent of complete observations by year
get_complete_cases_by_yr(tbl, appl_year)

```


```{r class_identification}

# converting application year to character so it doesn't get summarized with numerics
dat$appl_year <- as.character(dat$appl_year)


# converting study_id to factor so it is ignored during summaries
dat$study_id <- as.factor(dat$study_id)


classes <- dat %>% map(class) %>% unlist %>% unname


nums <- which(classes=="numeric")
binaries <- nums[apply(dat[nums], 2, function(x) { all(na.omit(x) %in% 0:1) })]
continuous <- setdiff(nums, binaries)
  
cats <- which(classes=="character")
dates <- which(classes=="POSIXct")



```

### Summary statistics for continuous variables

There are `r length(continuous)` continuous numeric variables in the dataset.

```{r summ_stats_cont_vars}


get_basic_summaries_single(dat, appl_year)

get_basic_summaries(df_list = tbl, varname = appl_year)


```

There are `r binaries` binary variables in the dataset. 
 
```{r binaries}

if (length(binaries) > 0) {
  
binary_mat <- matrix(NA, nrow=length(binaries), 2, dimnames=list(c(), 
                  c("N", "Proportion"))) 
  
binary_mat[i,1] <- sum(!is.na(dat[,binaries[i]]))
binary_mat[i,2] <- mean(dat[,binaries[i]], na.rm=TRUE)

row.names(binary_mat) <- names(dat)[binaries]

kable(binary_mat)

}

```


```{r}
#functions for binary data

appl %>% get_binary()
names(appl)


table(appl$ses, useNA = "always")
table(appl$dual_degree_applicant, useNA = "always")
table(appl$appl_type_desc, useNA = "always")


```





###Correlation Matrix

```{r corr_matrix}

kable(get_cor_mat_single(dat), type='html')

kable(get_cor_mat(tbl, round_digits = 3), type='html')


#group a list of tibbles by application year for each tibble and then return?
tbl %>%
  map(.,function(df) {
    df %>% 
      group_by(appl_year) %>% 
      nest() %>%
      mutate(var = map(data, get_cor_mat_single))
  }) %>%
  map(., "var", extract) 


# produces same output as above, but year names are preserved in list headers so output is more readable
tbl %>%
  map(., function(df) {
    df %>% 
      split(use_series(., appl_year)) %>% 
      lapply(select, -appl_year) %>%
      lapply(get_cor_mat_single)
} )


```


```{r histograms}

# rewrite this

# setting par settings so histograms display in a grid
par_rows <- length(continuous) %% 4 + 1
par(mfrow=c(par_rows, 4)) # add more par settings for better display

for (i in 1:par_rows) {
  hist(dat_cont[,i], main=names(dat_cont)[i], xlab="")
}

```



Number of distinct categories for each categorical variable (character vector) by year
```{r distinct_categories, results='asis'}


get_ndistinct_single(dat, appl_year) 

get_ndistinct(tbl, appl_year)


```


Tables of categorical variables
```{r categorical_tables}

cat_tabs <- get_cat_tables_single(dat, appl_year, prop=T, digits=3)
cat_tabs

get_cat_tables(tbl, appl_year)

# format tables for nice display 
categorical_kables <- lapply(names(cat_tabs), function(x) kable(cat_tabs[[x]], caption = x, type='html'))
# categorical_kables

```


```{r props_across_years, eval=FALSE}

# Provides N and proportin in each category across years
for (i in 1:length(cats)) {
  rawN <- sort(as.numeric(table(dat[,cats[i]])), decreasing=TRUE)
  prop <- sort(round(as.numeric(prop.table(table(dat[,cats[i]]))),2), decreasing=TRUE)

  col_names <- names(table(dat[,cats[i]]))
  
  if (length(rawN) > 10) {
    rawN <- rawN[1:10]
    prop <- prop[1:10]
    col_names <- names(table(dat[,cats[i]]))[1:10]
    }
  
  cells <- paste0(rawN, " (", prop, ")")
  names(cells) <- col_names
  #cells <- as.matrix(cells, ncol=4, dimnames = list(c(), col_names))

  print(kable(t(cells)), caption = names(dat[cats[i]]))
}

```

Summary Statistics for Date Variables
```{r dates}

get_basic_summaries_single2(appl, appl_year, is.POSIXct)

get_basic_summaries2(df_list = tbl, varname = appl_year, is.POSIXct)

```